# list of languages for which language servers are started; choose from:
#   al               bash             clojure          cpp              csharp           csharp_omnisharp
#   dart             elixir           elm              erlang           fortran          go
#   haskell          java             julia            kotlin           lua              markdown
#   nix              perl             php              python           python_jedi      r
#   rego             ruby             ruby_solargraph  rust             scala            swift
#   terraform        typescript       typescript_vts   yaml             zig
# Note:
#   - For C, use cpp
#   - For JavaScript, use typescript
# Special requirements:
#   - csharp: Requires the presence of a .sln file in the project folder.
# When using multiple languages, the first language server that supports a given file will be used for that file.
# The first language is the default language and the respective language server will be used as a fallback.
# Note that when using the JetBrains backend, language servers are not used and this list is correspondingly ignored.
languages:
- python
encoding: "utf-8"

# whether to use the project's gitignore file to ignore files
# Added on 2025-04-07
ignore_all_files_in_gitignore: true

# list of additional paths to ignore
# same syntax as gitignore, so you can use * and **
# Was previously called `ignored_dirs`, please update your config if you are using that.
# Added (renamed) on 2025-04-07
ignored_paths: []

# whether the project is in read-only mode
# If set to true, all editing tools will be disabled and attempts to use them will result in an error
# Added on 2025-04-18
read_only: false

# list of tool names to exclude. We recommend not excluding any tools, see the readme for more details.
# Below is the complete list of tools for convenience.
# To make sure you have the latest list of tools, and to view their descriptions, 
# execute `uv run scripts/print_tool_overview.py`.
#
#  * `activate_project`: Activates a project by name.
#  * `check_onboarding_performed`: Checks whether project onboarding was already performed.
#  * `create_text_file`: Creates/overwrites a file in the project directory.
#  * `delete_lines`: Deletes a range of lines within a file.
#  * `delete_memory`: Deletes a memory from Serena's project-specific memory store.
#  * `execute_shell_command`: Executes a shell command.
#  * `find_referencing_code_snippets`: Finds code snippets in which the symbol at the given location is referenced.
#  * `find_referencing_symbols`: Finds symbols that reference the symbol at the given location (optionally filtered by type).
#  * `find_symbol`: Performs a global (or local) search for symbols with/containing a given name/substring (optionally filtered by type).
#  * `get_current_config`: Prints the current configuration of the agent, including the active and available projects, tools, contexts, and modes.
#  * `get_symbols_overview`: Gets an overview of the top-level symbols defined in a given file.
#  * `initial_instructions`: Gets the initial instructions for the current project.
#     Should only be used in settings where the system prompt cannot be set,
#     e.g. in clients you have no control over, like Claude Desktop.
#  * `insert_after_symbol`: Inserts content after the end of the definition of a given symbol.
#  * `insert_at_line`: Inserts content at a given line in a file.
#  * `insert_before_symbol`: Inserts content before the beginning of the definition of a given symbol.
#  * `list_dir`: Lists files and directories in the given directory (optionally with recursion).
#  * `list_memories`: Lists memories in Serena's project-specific memory store.
#  * `onboarding`: Performs onboarding (identifying the project structure and essential tasks, e.g. for testing or building).
#  * `prepare_for_new_conversation`: Provides instructions for preparing for a new conversation (in order to continue with the necessary context).
#  * `read_file`: Reads a file within the project directory.
#  * `read_memory`: Reads the memory with the given name from Serena's project-specific memory store.
#  * `remove_project`: Removes a project from the Serena configuration.
#  * `replace_lines`: Replaces a range of lines within a file with new content.
#  * `replace_symbol_body`: Replaces the full definition of a symbol.
#  * `restart_language_server`: Restarts the language server, may be necessary when edits not through Serena happen.
#  * `search_for_pattern`: Performs a search for a pattern in the project.
#  * `summarize_changes`: Provides instructions for summarizing the changes made to the codebase.
#  * `switch_modes`: Activates modes by providing a list of their names
#  * `think_about_collected_information`: Thinking tool for pondering the completeness of collected information.
#  * `think_about_task_adherence`: Thinking tool for determining whether the agent is still on track with the current task.
#  * `think_about_whether_you_are_done`: Thinking tool for determining whether the task is truly completed.
#  * `write_memory`: Writes a named memory (for future reference) to Serena's project-specific memory store.
excluded_tools: []

# initial prompt for the project. It will always be given to the LLM upon activating the project
# (contrary to the memories, which are loaded on demand).
initial_prompt: |
  # MONITOR D&D Management System
  
  ## üéØ Project Overview
  MONITOR is an AI-powered Dungeon Master system for tabletop RPGs with a **data-first, canonization-driven architecture**.
  
  ## üèóÔ∏è Architecture (3 Layers - STRICT BOUNDARIES)
  
  **Layer 1 (data-layer)**: `packages/data-layer/`
  - MCP server exposing 64+ tools for data operations
  - Database clients: Neo4j (canonical graph), MongoDB (narrative docs), Qdrant (semantic search)
  - Authority enforcement middleware (controls who can write what)
  - Schema validation with Pydantic
  - **DEPENDS ON**: External libraries only
  - **CALLED BY**: Layer 2 (agents)
  
  **Layer 2 (agents)**: `packages/agents/`
  - 7 specialized AI agents:
    * **Orchestrator**: Loop management, coordinates agents
    * **CanonKeeper**: ONLY agent that writes to Neo4j (canonization)
    * **Narrator**: Generates narrative descriptions
    * **Resolver**: Dice rolls, rule resolution
    * **ContextAssembly**: Retrieves context from all databases
    * **MemoryManager**: Character memories
    * **Indexer**: Background indexing, semantic embeddings
  - 4 conversational loops: Main ‚Üí Story ‚Üí Scene ‚Üí Turn
  - **DEPENDS ON**: Layer 1 (data-layer)
  - **CALLED BY**: Layer 3 (cli)
  
  **Layer 3 (cli)**: `packages/cli/`
  - Command-line interface for users
  - Commands: play, manage, query, ingest, etc.
  - **DEPENDS ON**: Layer 2 (agents)
  - **CALLED BY**: End users
  
  ## ‚ö†Ô∏è CRITICAL RULES
  
  ### 1. Layer Dependency Enforcement
  ```
  L3 (cli) ‚Üí L2 (agents) ‚Üí L1 (data-layer) ‚Üí External libraries
  
  ‚ùå NEVER: L1 importing from L2 or L3
  ‚ùå NEVER: L2 importing from L3
  ‚úÖ ALWAYS: Check imports follow the layer hierarchy
  ```
  
  ### 2. CanonKeeper Exclusivity
  **ONLY CanonKeeper can write to Neo4j**
  - All other agents create `ProposedChange` documents in MongoDB
  - CanonKeeper evaluates proposals at scene end
  - Accepted proposals ‚Üí committed to Neo4j
  - This ensures canonical consistency
  
  ### 3. Proposal ‚Üí Canonization Workflow
  ```
  Player Action ‚Üí Resolver creates ProposedChange (MongoDB)
                ‚Üí Scene continues
                ‚Üí Scene ends
                ‚Üí CanonKeeper evaluates proposals
                ‚Üí Accepted ‚Üí Neo4j (canonical)
                ‚Üí Rejected ‚Üí Stays in MongoDB (non-canon)
  ```
  
  ### 4. Authority Matrix
  Each MCP tool has specific agent permissions defined in:
  - `packages/data-layer/src/monitor_data/middleware/auth.py`
  - Check before modifying permissions
  
  ## üìÅ Key Directories
  
  - `packages/data-layer/` - Layer 1 (MCP server, DB clients, schemas)
  - `packages/agents/` - Layer 2 (7 agents, loops, prompts)
  - `packages/cli/` - Layer 3 (CLI commands)
  - `docs/` - Architecture, ontology, implementation guides
  - `tests/` - Test suites (organized by layer)
  - `infra/` - Docker infrastructure
  - `.agent/` - Agent workflows and MCP server configs
  
  ## üìö Important Docs
  
  - `ARCHITECTURE.md` - Overall system architecture
  - `docs/architecture/DATABASE_INTEGRATION.md` - 5-database memory system
  - `docs/architecture/CONVERSATIONAL_LOOPS.md` - 4 nested loops
  - `docs/architecture/AGENT_ORCHESTRATION.md` - 7 agents coordination
  - `docs/architecture/DATA_LAYER_API.md` - Complete API spec (64+ tools)
  - `docs/architecture/MCP_TRANSPORT.md` - MCP tool definitions
  
  ## üîß When Editing Code
  
  1. **Check layer boundaries** - Never violate the L3‚ÜíL2‚ÜíL1 dependency rule
  2. **Authority matrix** - Verify agent permissions before modifying tool access
  3. **Add tests** - Every new feature needs tests in `tests/`
  4. **Evidence pattern** - All canonical data needs `evidence_refs`
  5. **Use cases** - Reference relevant use case (DL-*, P-*, M-*, Q-*, etc.)
  6. **Type hints** - Use Pydantic models for validation
  7. **CanonKeeper** - Only this agent writes to Neo4j
  
  ## üóÑÔ∏è Database Responsibilities
  
  - **Neo4j**: Canonical truth (universes, entities, facts, events) - CanonKeeper writes only
  - **MongoDB**: Narrative layer (scenes, turns, proposals, memories) - Any agent can write
  - **Qdrant**: Vector embeddings for semantic search - Indexer writes only
  - **MinIO**: Binary storage (PDFs, images) - Ingest pipeline
  - **OpenSearch**: Full-text search - Indexer writes only
  
  ## üéÆ Common Tasks
  
  **Adding a new data layer tool**:
  1. Define in `packages/data-layer/src/monitor_data/tools/[neo4j|mongodb|qdrant]_tools.py`
  2. Add Pydantic schema in `packages/data-layer/src/monitor_data/schemas/`
  3. Add authority rule in `packages/data-layer/src/monitor_data/middleware/auth.py`
  4. Add tests in `tests/data-layer/`
  5. Document in `docs/architecture/DATA_LAYER_API.md`
  
  **Adding a new agent**:
  1. Create in `packages/agents/src/monitor_agents/[agent_name].py`
  2. Inherit from `BaseAgent`
  3. Define which tools the agent can call
  4. Add prompts in `packages/agents/src/monitor_agents/prompts/`
  5. Add tests in `tests/agents/`
  
  **Adding a CLI command**:
  1. Create in `packages/cli/src/monitor_cli/commands/[command].py`
  2. Use Typer for CLI
  3. Import from agents layer (L2) only, never from data-layer (L1)
  4. Add tests in `tests/cli/`

project_name: "monitor2"
included_optional_tools: []
fixed_tools: []
